using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AspectSourceGenerator
{
    [Generator]
    public class AspectGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all type declarations (classes, structs, records)
            IncrementalValuesProvider<(TypeDeclarationSyntax TypeDeclaration, SemanticModel Semantic)> typeDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is TypeDeclarationSyntax,
                transform: (ctx, _) => (TypeDeclaration: (TypeDeclarationSyntax)ctx.Node, Semantic: ctx.SemanticModel))
                .Where(t => t.TypeDeclaration != null);

            IncrementalValuesProvider<INamedTypeSymbol?> aspectTypes = typeDeclarations.Select((t, _) =>
            {
                SemanticModel? model = t.Semantic;
                TypeDeclarationSyntax? td = t.TypeDeclaration;
                INamedTypeSymbol? symbol = model.GetDeclaredSymbol(td) as INamedTypeSymbol;
                return symbol;
            }).Where(sym => sym != null)
            .Where(sym => sym != null && sym.AllInterfaces.Any(i => i.OriginalDefinition.ToDisplayString() == "Yogurt.IAspect"));

            // Collect aspects and produce source
            IncrementalValueProvider<ImmutableArray<INamedTypeSymbol?>> collected = aspectTypes.Collect();

            context.RegisterSourceOutput(collected, (ctx, types) =>
            {
                if (types == null || types.Length == 0) return;

                StringBuilder sb = new System.Text.StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("using System;");
                sb.AppendLine("using Yogurt;");
                sb.AppendLine("namespace Yogurt");
                sb.AppendLine("{");
                sb.AppendLine("    public static partial class AspectExtensions_Roslyn");
                sb.AppendLine("    {");

                foreach (INamedTypeSymbol? t in types.OrderBy(t => t?.ToDisplayString()))
                {
                    string? fullname = t?.ToDisplayString();
                    string access = GetAccessibilityString(t!);
                    sb.AppendLine($"""
                                          // {fullname}
                                          {access} static TComponent Get<TComponent>(this {fullname} aspect)  where TComponent : IComponent => aspect.Entity.Get<TComponent>();
                                          {access} static bool TryGet<TComponent>(this {fullname} aspect, out TComponent component)  where TComponent : IComponent => aspect.Entity.TryGet(out component);
                                          {access} static void Add<TComponent>(this {fullname} aspect, TComponent component)  where TComponent : IComponent => aspect.Entity.Set(component);
                                          {access} static void Set<TComponent>(this {fullname} aspect, TComponent component)  where TComponent : IComponent => aspect.Entity.Set(component);
                                          {access} static bool Has<TComponent>(this {fullname} aspect)  where TComponent : IComponent => aspect.Entity.Has<TComponent>();
                                          {access} static void Remove<TComponent>(this {fullname} aspect)  where TComponent : IComponent => aspect.Entity.Remove<TComponent>();
                                      
                                  """);
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                ctx.AddSource("gen.AspectExtensions_Roslyn.cs", SourceText.From(sb.ToString(), System.Text.Encoding.UTF8));
            });
        }
        
        private static string GetAccessibilityString(INamedTypeSymbol symbol)
        {
            switch (symbol.DeclaredAccessibility)
            {
                case Accessibility.Public:
                    return "public";
                case Accessibility.Internal:
                case Accessibility.ProtectedAndInternal:
                case Accessibility.ProtectedOrInternal:
                    return "internal";
                default:
                    // Private/protected/nested-only: fallback to internal so generated extensions are emit-able at namespace scope.
                    return "internal";
            }
        }
    }
}